#!/usr/bin/python3
import rclpy
from rclpy.node import Node
import numpy as np
from geometry_msgs.msg import Quaternion, Twist, Pose
from nav_msgs.msg import Odometry
from sensor_msgs.msg import Imu
from tf_transformations import euler_from_quaternion, quaternion_from_euler

class EKFFusion(Node):
    def __init__(self):
        super().__init__('ekf_fusion_node')
        
        # State vector [x, y, theta, vx, vy, omega]
        self.x_hat = np.zeros((6, 1))
        
        # State covariance matrix
        self.P = np.eye(6)
        
        # Process noise covariance matrix
        self.Q = np.diag([0.01, 0.01, 0.01, 0.01, 0.01, 0.01])
        
        # Measurement noise covariance matrix for wheel odometry
        self.R_wheel = np.diag([0.1, 0.1, 0.1])
        
        # Measurement noise covariance matrix for IMU
        self.R_imu = np.diag([0.01, 0.01, 0.01])
        
        # Wheel odometry subscriber
        self.odom_sub = self.create_subscription(Odometry, '/wheel/odometry', self.odom_callback, 10)
        
        # IMU subscriber
        self.imu_sub = self.create_subscription(Imu, '/imu/data', self.imu_callback, 10)
        
        # Fused odometry publisher
        self.fused_odom_pub = self.create_publisher(Odometry, '/fused_odom', 10)
        
    def odom_callback(self, odom_msg):
        # Extract wheel odometry measurements
        x_wheel = odom_msg.pose.pose.position.x
        y_wheel = odom_msg.pose.pose.position.y
        theta_wheel = euler_from_quaternion([
            odom_msg.pose.pose.orientation.x,
            odom_msg.pose.pose.orientation.y,
            odom_msg.pose.pose.orientation.z,
            odom_msg.pose.pose.orientation.w])[2]
        
        # Construct the measurement vector for wheel odometry
        z_wheel = np.array([[x_wheel, y_wheel, theta_wheel]]).T
        
        # Jacobian matrix for the wheel odometry measurement model
        H_wheel = np.array([
            [1, 0, 0, 0, 0, 0],
            [0, 1, 0, 0, 0, 0],
            [0, 0, 1, 0, 0, 0]
        ])
        
        # Kalman gain for wheel odometry
        K_wheel = self.P.dot(H_wheel.T).dot(np.linalg.inv(H_wheel.dot(self.P).dot(H_wheel.T) + self.R_wheel))
        
        # Update the state estimate based on wheel odometry measurement
        self.x_hat = self.x_hat + K_wheel.dot(z_wheel - H_wheel.dot(self.x_hat))
        
        # Update the covariance matrix
        self.P = (np.eye(6) - K_wheel.dot(H_wheel)).dot(self.P)
        
    def imu_callback(self, imu_msg):
        # Extract IMU measurements
        omega_imu = imu_msg.angular_velocity.z  # Assuming the yaw rate is in the z-axis
        
        # Construct the measurement vector for IMU
        z_imu = np.array([[omega_imu]])
        
        # Jacobian matrix for the IMU measurement model
        H_imu = np.array([[0, 0, 1, 0, 0, 0]])
        
        # Kalman gain for IMU
        K_imu = self.P.dot(H_imu.T).dot(np.linalg.inv(H_imu.dot(self.P).dot(H_imu.T) + self.R_imu))
        
        # Update the state estimate based on IMU measurement
        self.x_hat = self.x_hat + K_imu.dot(z_imu - H_imu.dot(self.x_hat))
        
        # Update the covariance matrix
        self.P = (np.eye(6) - K_imu.dot(H_imu)).dot(self.P)
        
    def publish_fused_odom(self):
        # Create Odometry message for fused odometry
        fused_odom_msg = Odometry()
        fused_odom_msg.header.stamp = self.get_clock().now().to_msg()
        fused_odom_msg.header.frame_id = 'odom'
        fused_odom_msg.child_frame_id = 'base_link'
        
        # Populate the pose information
        fused_odom_msg.pose.pose.position.x = self.x_hat[0, 0]
        fused_odom_msg.pose.pose.position.y = self.x_hat[1, 0]
        quat = quaternion_from_euler(0, 0, self.x_hat[2, 0])
        # fused_odom_msg.pose.pose.orientation = Quaternion(*quaternion_from_euler(0, 0, self.x_hat[2, 0]))
        fused_odom_msg.pose.pose.orientation.x = quat[0]
        fused_odom_msg.pose.pose.orientation.y = quat[1]
        fused_odom_msg.pose.pose.orientation.z = quat[2]
        fused_odom_msg.pose.pose.orientation.w = quat[3]
        
        # Populate the twist information
        fused_odom_msg.twist.twist.linear.x = self.x_hat[3, 0]
        fused_odom_msg.twist.twist.linear.y = self.x_hat[4, 0]
        fused_odom_msg.twist.twist.angular.z = self.x_hat[5, 0]
        
        # Publish the fused odometry
        self.fused_odom_pub.publish(fused_odom_msg)
        
    def run(self):
        while rclpy.ok():
            self.publish_fused_odom()
            rclpy.spin_once(self)

if __name__ == '__main__':
    rclpy.init()
    ekf_fusion = EKFFusion()
    ekf_fusion.run()
    rclpy.shutdown()
